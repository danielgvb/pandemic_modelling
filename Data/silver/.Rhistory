# Step 4: Create a data frame for plotting
plot_data <- data.frame(
Time = df_ggm$Time,
Actual = df_ggm$Cases,
Fitted = arima_fitted
)
# Step 5: Plot actual vs. fitted values
plot <- ggplot(plot_data, aes(x = Time)) +
geom_line(aes(y = Actual, color = "Actual"), linewidth = 1) +
geom_line(aes(y = Fitted, color = "Fitted"), linewidth = 1, linetype = "dashed") +
labs(
title = paste("Actual vs. Fitted Values for", country),
x = "Time",
y = "Cases",
color = "Legend"
) +
theme_minimal() +
scale_color_manual(values = c("Actual" = "blue", "Fitted" = "red")) +
theme(
legend.position = c(0.9, 0.1), #Bottom right
legend.justification = c(1, 1), # Anchor the legend at the top-right corner
legend.box.background = element_rect(color = "black", size = 0.5), # Add a border to the legend
legend.box.margin = margin(6, 6, 6, 6) # Add some margin around the legend
)
return(plot)
}
## 6.1 Daily-------------------
# Iterate over each country and process
plot_list <- lapply(unique_countries, function(country) {
process_country(country, df_d)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
# Function to process each country
process_country <- function(country, df, save_dir = "plots") {
# Step 1: Get GGM residuals, fitted values, and actual cases
df_ggm <- ggm_residuals(country, df)
# Step 2: Fit auto.arima using GGM fitted values as xreg
arima_model <- auto.arima(df_ggm$Cases, xreg = df_ggm$Fitted)
# Step 3: Get fitted values from the ARIMA model
arima_fitted <- fitted(arima_model)
# Step 4: Create a data frame for plotting
plot_data <- data.frame(
Time = df_ggm$Time,
Actual = df_ggm$Cases,
Fitted = arima_fitted
)
# Step 5: Plot actual vs. fitted values
plot <- ggplot(plot_data, aes(x = Time)) +
geom_line(aes(y = Actual, color = "Actual"), linewidth = 1) +
geom_line(aes(y = Fitted, color = "Fitted"), linewidth = 1, linetype = "dashed") +
labs(
title = paste("Actual vs. Fitted Values for", country),
x = "Time",
y = "Cases",
color = "Legend"
) +
theme_minimal() +
scale_color_manual(values = c("Actual" = "blue", "Fitted" = "red")) +
theme(
legend.position = c(0.9, 0.1), #Bottom right
)
return(plot)
}
## 6.1 Daily-------------------
# Iterate over each country and process
plot_list <- lapply(unique_countries, function(country) {
process_country(country, df_d)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
# Function to process each country
process_country <- function(country, df, save_dir = "plots") {
# Step 1: Get GGM residuals, fitted values, and actual cases
df_ggm <- ggm_residuals(country, df)
# Step 2: Fit auto.arima using GGM fitted values as xreg
arima_model <- auto.arima(df_ggm$Cases, xreg = df_ggm$Fitted)
# Step 3: Get fitted values from the ARIMA model
arima_fitted <- fitted(arima_model)
# Step 4: Create a data frame for plotting
plot_data <- data.frame(
Time = df_ggm$Time,
Actual = df_ggm$Cases,
Fitted = arima_fitted
)
# Step 5: Plot actual vs. fitted values
plot <- ggplot(plot_data, aes(x = Time)) +
geom_line(aes(y = Actual, color = "Actual"), linewidth = 1) +
geom_line(aes(y = Fitted, color = "Fitted"), linewidth = 1, linetype = "dashed") +
labs(
title = paste(country),
x = "Time",
y = "Cases",
color = "Legend"
) +
theme_minimal() +
scale_color_manual(values = c("Actual" = "blue", "Fitted" = "red")) +
theme(
legend.position = c(0.9, 0.1), #Bottom right
)
return(plot)
}
## 6.1 Daily-------------------
# Iterate over each country and process
plot_list <- lapply(unique_countries, function(country) {
process_country(country, df_d)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
## 6.1 Weekly-------------------
# Iterate over each country and process
plot_list <- lapply(unique_countries, function(country) {
process_country(country, df_w)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
## 6.3 Monthly-------------------
# Iterate over each country and process
plot_list <- lapply(unique_countries, function(country) {
process_country(country, df_m)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
# Function to compute R² and RMSE for each country
process_country_metrics <- function(country, df) {
# Step 1: Get GGM residuals, fitted values, and actual cases
df_ggm <- ggm_residuals(country, df)
# Step 2: Fit auto.arima using GGM fitted values as xreg
arima_model <- auto.arima(df_ggm$Cases, xreg = df_ggm$Fitted)
# Step 3: Get fitted values from the ARIMA model
arima_fitted <- fitted(arima_model)
# Step 4: Compute R² and RMSE
actual <- df_ggm$Cases
fitted <- arima_fitted
# R² calculation
ss_total <- sum((actual - mean(actual))^2)
ss_residual <- sum((actual - fitted)^2)
r_squared <- 1 - (ss_residual / ss_total)
# RMSE calculation
rmse <- sqrt(mean((actual - fitted)^2))
# Step 5: Return results as a data frame
result <- data.frame(
Country = country,
R2 = r_squared,
RMSE = rmse
)
return(result)
}
metrics_df <- lapply(unique_countries, function(country) {
process_country_metrics(country, df_d)
}) %>% bind_rows()
# Print the resulting data frame
print(metrics_df)
View(metrics_df)
metrics_df <- lapply(unique_countries, function(country) {
process_country_metrics(country, df_w)
}) %>% bind_rows()
View(metrics_df)
metrics_df <- lapply(unique_countries, function(country) {
process_country_metrics(country, df_m)
}) %>% bind_rows()
View(metrics_df)
# 8. Load data
df_dengue <- read.csv("dengue_no_split.csv")
df_zika<- read.csv("zika.csv")
df_chic <- read.csv("chicunguya.csv")
head(df_dengue)
tsdisplay(df_dengue$Casos)
tsdisplay(df_zika$Casos)
tsdisplay(df_dengue$Casos)
plot(df_dengue$Casos)
tsplot(df_dengue$Casos)
plot(df_dengue$Casos)
plot(df_dengue$Casos)
plot(df_zika$Casos)
plot(df_chicunguya$Casos)
head(df_dengue)
# Sort the data by DATE (if not already sorted)
df_dengue <- df_dengue %>% arrange(DATE)
# 9. Adjust format--------------------
# Ensure the DATE column is in Date format
df_dengue$DATE <- as.Date(df_dengue$DATE)
# Sort the data by DATE (if not already sorted)
df_dengue <- df_dengue %>% arrange(DATE)
# Create a time series object
ts_dengue <- ts(df_dengue$Casos, frequency = 52, start = c(year(min(df_dengue$DATE)), week(min(df_dengue$DATE))))
# 9. Adjust format--------------------
# Ensure the DATE column is in Date format
df_dengue$DATE <- as.Date(df_dengue$DATE)
# Sort the data by DATE (if not already sorted)
df_dengue <- df_dengue %>% arrange(DATE)
# Create a time series object
ts_dengue <- ts(df_dengue$Casos, frequency = 52, start = c(year(min(df_dengue$DATE)), week(min(df_dengue$DATE))))
# 9. Adjust format--------------------
# Ensure the DATE column is in Date format
df_dengue$DATE <- as.Date(df_dengue$DATE)
# Sort the data by DATE (if not already sorted)
df_dengue <- df_dengue %>% arrange(DATE)
# Generate a sequence of expected weekly dates
expected_dates <- seq(min(df_dengue$DATE), max(df_dengue$DATE), by = "week")
# Find missing dates
missing_dates <- expected_dates[!expected_dates %in% df_dengue$DATE]
# Print missing dates
if (length(missing_dates) > 0) {
cat("Missing dates in the dataframe:\n")
print(missing_dates)
} else {
cat("No missing dates. The dataframe has regular weekly data.\n")
}
library(zoo)
# Ensure the DATE column is in Date format
df_dengue$DATE <- as.Date(df_dengue$DATE)
# Sort the data by DATE (if not already sorted)
df_dengue <- df_dengue %>% arrange(DATE)
# Generate a full sequence of weekly dates
full_dates <- seq(min(df_dengue$DATE), max(df_dengue$DATE), by = "week")
# Create a dataframe with the full sequence of dates
full_df <- data.frame(DATE = full_dates)
# Merge the full sequence with your dataframe
merged_df <- full_df %>%
left_join(df_dengue, by = "DATE")
# Interpolate missing values in the Casos column
merged_df$Casos <- na.approx(merged_df$Casos)
# Print the interpolated dataframe
head(merged_df)
# Merge the full sequence with your dataframe
merged_df_dengue <- full_df %>%
left_join(df_dengue, by = "DATE")
# Interpolate missing values in the Casos column
merged_df_dengue$Casos <- na.approx(merged_df$Casos)
# Print the interpolated dataframe
head(merged_df_dengue)
## 9.1 Time series objects------------
# Load necessary library
library(lubridate)
# Ensure the DATE column is in Date format
merged_df_dengue$DATE <- as.Date(merged_df$DATE)
View(merged_df)
# Create a time series object
ts_casos_dengue <- ts(
merged_df_dengue$Casos,
frequency = 52,
start = c(
year(min(merged_df_dengue$DATE)),
week(min(merged_df_dengue$DATE))
)
)
plot(ts_casos_dengue, main = "Weekly Dengue Cases", xlab = "Time", ylab = "Casos")
plot(diff(ts_casos_dengue), main = "Weekly Dengue Cases-Diff", xlab = "Time", ylab = "Casos")
## Zika--------------------
# Ensure the DATE column is in Date format
df_zika$DATE <- as.Date(df_zika$DATE)
# Sort the data by DATE (if not already sorted)
df_zika <- df_zika %>% arrange(DATE)
# Generate a sequence of expected weekly dates
expected_dates <- seq(min(df_zika$DATE), max(df_zika$DATE), by = "week")
# Find missing dates
missing_dates <- expected_dates[!expected_dates %in% df_zika$DATE]
# Print missing dates
if (length(missing_dates) > 0) {
cat("Missing dates in the dataframe:\n")
print(missing_dates)
} else {
cat("No missing dates. The dataframe has regular weekly data.\n")
}
## Zika--------------------
# Ensure the DATE column is in Date format
df_zika$DATE <- as.Date(df_zika$DATE)
# Sort the data by DATE (if not already sorted)
df_zika <- df_zika %>% arrange(DATE)
# Generate a sequence of expected weekly dates
expected_dates <- seq(min(df_zika$DATE), max(df_zika$DATE), by = "week")
# Find missing dates
missing_dates <- expected_dates[!expected_dates %in% df_zika$DATE]
# Print missing dates
if (length(missing_dates) > 0) {
cat("Missing dates in the dataframe:\n")
print(missing_dates)
} else {
cat("No missing dates. The dataframe has regular weekly data.\n")
}
## Zika--------------------
# Ensure the DATE column is in Date format
df_zika$DATE <- as.Date(df_zika$DATE)
### 9.1.1 Dengue-------------------
# Load necessary library
library(lubridate)
# Ensure the DATE column is in Date format
merged_df_dengue$DATE <- as.Date(merged_df$DATE)
# Create a time series object
ts_casos_dengue <- ts(
merged_df_dengue$Casos,
frequency = 52,
start = c(
year(min(merged_df_dengue$DATE)),
week(min(merged_df_dengue$DATE))
)
)
# 8. Load data
df_dengue <- read.csv("dengue_no_split.csv")
df_zika<- read.csv("zika.csv")
df_chic <- read.csv("chicunguya.csv")
head(df_dengue)
plot(df_dengue$Casos)
plot(df_zika$Casos)
plot(df_chicunguya$Casos)
### 9.1.1 Dengue-------------------
# Load necessary library
library(lubridate)
# Ensure the DATE column is in Date format
df_dengue$DATE <- as.Date(df_dengue$DATE)
# Create a time series object
ts_casos_dengue <- ts(
df_dengue$Casos,
frequency = 52,
start = c(
year(min(df_dengue$DATE)),
week(min(df_dengue$DATE))
)
)
plot(ts_casos_dengue, main = "Weekly Dengue Cases", xlab = "Time", ylab = "Casos")
plot(diff(ts_casos_dengue), main = "Weekly Dengue Cases-Diff", xlab = "Time", ylab = "Casos")
# Ensure the DATE column is in Date format
df_zika$DATE <- as.Date(df_zika$DATE)
# Ensure the DATE column is in Date format
df_zika$DATE <- as.Date(df_zika$DATE)
# Create a time series object
ts_casos_zika <- ts(
df_zika$Casos,
frequency = 52,
start = c(
year(min(df_zika$DATE)),
week(min(df_zika$DATE))
)
)
plot(ts_casos_zika, main = "Weekly Zika Cases", xlab = "Time", ylab = "Casos")
plot(diff(ts_casos_zika), main = "Weekly Dengue Zika-Diff", xlab = "Time", ylab = "Casos")
# Ensure the DATE column is in Date format
df_chic$DATE <- as.Date(df_chic$DATE)
# Create a time series object
ts_casos_chic <- ts(
df_chic$Casos,
frequency = 52,
start = c(
year(min(df_chic$DATE)),
week(min(df_chic$DATE))
)
)
# Ensure the DATE column is in Date format
df_chic$DATE <- as.Date(df_chic$DATE)
# Create a time series object
ts_casos_chic <- ts(
df_chic$Casos,
frequency = 52,
start = c(
year(min(df_chic$DATE)),
week(min(df_chic$DATE))
)
)
plot(ts_casos_chic, main = "Weekly Zika Cases", xlab = "Time", ylab = "Casos")
plot(diff(ts_casos_zika), main = "Weekly Zika Zika-Diff", xlab = "Time", ylab = "Casos")
# Ensure the DATE column is in Date format
df_chic$DATE <- as.Date(df_chic$DATE)
# Create a time series object
ts_casos_chic <- ts(
df_chic$Casos,
frequency = 52,
start = c(
year(min(df_chic$DATE)),
week(min(df_chic$DATE))
)
)
plot(ts_casos_chic, main = "Weekly Chicunguya Cases", xlab = "Time", ylab = "Casos")
plot(diff(ts_casos_chic), main = "Weekly Chicunguya Zika-Diff", xlab = "Time", ylab = "Casos")
plot(diff(ts_casos_zika), main = "Weekly Zika-Diff", xlab = "Time", ylab = "Casos")
# countries
unique_countries <- unique(df_d$country)
unique_countries
# Loop through the first 10 countries (to fit 2x5 grid)
plot_list <- lapply(unique_countries, function(country) {
plot_bm_model(country, df_d)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
# Loop through the first 10 countries (to fit 2x5 grid)
plot_list <- lapply(unique_countries, function(country) {
plot_bm_model(country, df_w)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
grid.arrange(
grobs = plot_list,
nrow = 2,
ncol = 5,
padding = unit(0, "line"),  # Reduce padding between plots
widths = rep(1, 5),         # Equal widths for columns
heights = rep(1, 2)         # Equal heights for rows
)
return(p)
# Define function to fit Bass model and generate plot for each country
plot_bm_model <- function(country_name, df) {
# Filter data for the specific country
df_country <- df %>% filter(country == country_name)
covid_series <- df_country$new_cases
# Train BM model on first n days
bm_model <- BM(covid_series, display = FALSE)
# Forecast for the entire period
fitted_forecast <- predict(bm_model, newx = c(1:length(covid_series)))
# Compute instantaneous fitted values
fitted_forecast_inst <- make.instantaneous(fitted_forecast)
# Create plot using ggplot2
df_plot <- data.frame(
Time = 1:length(covid_series),
Actual = covid_series,
Fitted = fitted_forecast_inst
)
p <- ggplot(df_plot, aes(x = Time)) +
geom_line(aes(y = Actual), color = "black", size = 1) +
geom_line(aes(y = Fitted), color = "red", linetype = "dashed", size = 1) +
ggtitle(paste("COVID-19 Cases in", country_name)) +
ylab("Cases") + xlab("Time") +
theme_minimal()+
+
theme(
text = element_text(size = 8),               # Reduce general text size
axis.text = element_text(size = 8),          # Reduce axis tick label size
axis.title = element_text(size = 8),         # Reduce axis title size
plot.title = element_text(size = 10),         # Reduce plot title size
legend.text = element_text(size = 8),         # Reduce legend text size
legend.title = element_text(size = 8),        # Reduce legend title size
plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")  # Reduce plot margins
)
return(p)
}
# Loop through the first 10 countries (to fit 2x5 grid)
plot_list <- lapply(unique_countries, function(country) {
plot_bm_model(country, df_w)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
# Define function to fit Bass model and generate plot for each country
plot_bm_model <- function(country_name, df) {
# Filter data for the specific country
df_country <- df %>% filter(country == country_name)
covid_series <- df_country$new_cases
# Train BM model on first n days
bm_model <- BM(covid_series, display = FALSE)
# Forecast for the entire period
fitted_forecast <- predict(bm_model, newx = c(1:length(covid_series)))
# Compute instantaneous fitted values
fitted_forecast_inst <- make.instantaneous(fitted_forecast)
# Create plot using ggplot2
df_plot <- data.frame(
Time = 1:length(covid_series),
Actual = covid_series,
Fitted = fitted_forecast_inst
)
p <- ggplot(df_plot, aes(x = Time)) +
geom_line(aes(y = Actual, color = "Actual"), size = 1) +
geom_line(aes(y = Fitted, color = "Fitted"), linetype = "dashed", size = 1) +
scale_color_manual(values = c("Actual" = "black", "Fitted" = "red")) +
labs(color = "Legend") +  # Legend title
ggtitle(paste("COVID-19 Cases in", country_name)) +
ylab("Cases") +
xlab("Time") +
theme_minimal() +
theme(
text = element_text(size = 8),
axis.text = element_text(size = 8),
axis.title = element_text(size = 8),
plot.title = element_text(size = 10),
legend.text = element_text(size = 8),
legend.title = element_text(size = 8),
plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm")
)
return(p)
}
# Loop through the first 10 countries (to fit 2x5 grid)
plot_list <- lapply(unique_countries, function(country) {
plot_bm_model(country, df_w)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
grid.arrange(
grobs = plot_list,
nrow = 2,
ncol = 5,
padding = unit(0, "line"),  # Reduce padding between plots
widths = rep(1, 5),         # Equal widths for columns
heights = rep(1, 2)         # Equal heights for rows
)
# Loop through the first 10 countries (to fit 2x5 grid)
plot_list <- lapply(unique_countries, function(country) {
plot_bm_model(country, df_d)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
# Loop through the first 10 countries (to fit 2x5 grid)
plot_list <- lapply(unique_countries, function(country) {
plot_ggm_model(country, df_d)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
## 6.1 Daily-------------------
# Iterate over each country and process
plot_list <- lapply(unique_countries, function(country) {
process_country(country, df_d)
})
# Arrange plots in a 2x5 grid
grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
